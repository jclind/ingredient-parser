import numericQuantity from "numeric-quantity";
const fors = ["For"];
const forsRegEx = new RegExp(`^(?:${fors.join("|")})\\s`, "i");
const rangeSeparatorWords = ["or", "to"];
const rangeSeparatorRegEx = new RegExp(
  `^(-|\u2013|\u2014|(?:${rangeSeparatorWords.join("|")})\\s)`,
  "i"
);
const firstWordRegEx = /^(fl(?:uid)?(?:\s+|-)(?:oz|ounces?)|\w+[-.]?)(.+)/;
const ofs = ["of"];
const ofRegEx = new RegExp(`^(?:${ofs.join("|")})\\s+`, "i");
const unitsOfMeasure = {
  bag: { short: "bag", plural: "bags", alternates: [] },
  box: { short: "box", plural: "boxes", alternates: [] },
  bunch: { short: "bunch", plural: "bunches", alternates: [] },
  can: { short: "can", plural: "cans", alternates: [] },
  carton: { short: "carton", plural: "cartons", alternates: [] },
  centimeter: { short: "cm", plural: "centimeters", alternates: ["cm."] },
  clove: { short: "clove", plural: "cloves", alternates: [] },
  container: { short: "container", plural: "containers", alternates: [] },
  cup: { short: "c", plural: "cups", alternates: ["c.", "C"] },
  dash: { short: "dash", plural: "dashes", alternates: [] },
  drop: { short: "drop", plural: "drops", alternates: [] },
  ear: { short: "ear", plural: "ears", alternates: [] },
  "fluid ounce": { short: "fl oz", plural: "fluid ounces", alternates: ["fluidounce", "floz", "fl-oz", "fluid-ounce", "fluid-ounces", "fluidounces", "fl ounce", "fl ounces", "fl-ounce", "fl-ounces", "fluid oz", "fluid-oz"] },
  foot: { short: "ft", plural: "feet", alternates: ["ft."] },
  gallon: { short: "gal", plural: "gallons", alternates: ["gal."] },
  gram: { short: "g", plural: "grams", alternates: ["g."] },
  head: { short: "head", plural: "heads", alternates: [] },
  inch: { short: "in", plural: "inches", alternates: ["in."] },
  kilogram: { short: "kg", plural: "kilograms", alternates: ["kg."] },
  large: { short: "lg", plural: "large", alternates: ["lg", "lg."] },
  liter: { short: "l", plural: "liters", alternates: [] },
  medium: { short: "md", plural: "medium", alternates: ["med", "med.", "md."] },
  meter: { short: "m", plural: "meters", alternates: ["m."] },
  milligram: { short: "mg", plural: "milligrams", alternates: ["mg."] },
  milliliter: { short: "ml", plural: "milliliters", alternates: ["mL", "ml.", "mL."] },
  millimeter: { short: "mm", plural: "millimeters", alternates: ["mm."] },
  ounce: { short: "oz", plural: "ounces", alternates: ["oz."] },
  pack: { short: "pack", plural: "packs", alternates: [] },
  package: { short: "pkg", plural: "packages", alternates: ["pkg.", "pkgs"] },
  piece: { short: "piece", plural: "pieces", alternates: ["pcs", "pcs."] },
  pinch: { short: "pinch", plural: "pinches", alternates: [] },
  pint: { short: "pt", plural: "pints", alternates: ["pt."] },
  pound: { short: "lb", plural: "pounds", alternates: ["lb.", "lbs", "lbs."] },
  quart: { short: "qt", plural: "quarts", alternates: ["qt.", "qts", "qts."] },
  small: { short: "sm", plural: "small", alternates: ["sm."] },
  sprig: { short: "sprig", plural: "sprigs", alternates: [] },
  stick: { short: "stick", plural: "sticks", alternates: [] },
  tablespoon: { short: "tbsp", plural: "tablespoons", alternates: ["tbsp.", "T", "Tbsp."] },
  teaspoon: { short: "tsp", plural: "teaspoons", alternates: ["tsp.", "t"] },
  yard: { short: "yd", plural: "yards", alternates: ["yd.", "yds."] }
};
const compactArray = (array) => {
  let index = -1;
  const length = array.length;
  let resIndex = 0;
  const result = [];
  while (++index < length) {
    const value = array[index];
    if (value) {
      result[resIndex++] = value;
    }
  }
  return result;
};
const parseIngredient = (ingText, options) => {
  const mergedUOMs = { ...unitsOfMeasure, ...options == null ? void 0 : options.additionalUOMs };
  const uomArray = Object.keys(mergedUOMs).map((uom) => ({ id: uom, ...mergedUOMs[uom] }));
  const arrRaw = compactArray(
    ingText.replace(/\n{2,}/g, "\n").split("\n").map((ing) => ing.trim())
  );
  const arrIngs = arrRaw.map((line) => {
    const oIng = {
      quantity: null,
      quantity2: null,
      unitOfMeasureID: null,
      unitOfMeasure: null,
      description: "",
      isGroupHeader: false
    };
    const nqResultFirstChar = numericQuantity(line.substring(0, 1));
    if (isNaN(nqResultFirstChar)) {
      oIng.description = line;
      if (/:$/.test(oIng.description) || forsRegEx.test(oIng.description)) {
        oIng.isGroupHeader = true;
      }
    } else {
      let lenNum = 6;
      let nqResult = NaN;
      while (lenNum > 0 && isNaN(nqResult)) {
        nqResult = numericQuantity(line.substring(0, lenNum).trim());
        if (nqResult > -1) {
          oIng.quantity = nqResult;
          oIng.description = line.substring(lenNum).trim();
        }
        lenNum--;
      }
    }
    const q2reMatch = rangeSeparatorRegEx.exec(oIng.description);
    if (q2reMatch) {
      const q2reMatchLen = q2reMatch[1].length;
      const nqResultFirstChar2 = numericQuantity(
        oIng.description.substring(q2reMatchLen).trim().substring(0, 1)
      );
      if (!isNaN(nqResultFirstChar2)) {
        let lenNum = 6;
        let nqResult = NaN;
        while (lenNum > 0 && isNaN(nqResult)) {
          nqResult = numericQuantity(oIng.description.substring(q2reMatchLen, lenNum));
          if (!isNaN(nqResult)) {
            oIng.quantity2 = nqResult;
            oIng.description = oIng.description.substring(lenNum).trim();
          }
          lenNum--;
        }
      }
    }
    const firstWordREMatches = firstWordRegEx.exec(oIng.description);
    if (firstWordREMatches) {
      const firstWord = firstWordREMatches[1].replace(/\s+/g, " ");
      const remainingDesc = firstWordREMatches[2];
      let uom = "";
      let uomID = "";
      let i = 0;
      while (i < uomArray.length && !uom) {
        const versions = [
          ...uomArray[i].alternates,
          uomArray[i].id,
          uomArray[i].short,
          uomArray[i].plural
        ];
        if (versions.includes(firstWord)) {
          uom = firstWord;
          uomID = uomArray[i].id;
        }
        i++;
      }
      if (uom) {
        oIng.unitOfMeasureID = uomID;
        if (options == null ? void 0 : options.normalizeUOM) {
          oIng.unitOfMeasure = uomID;
        } else {
          oIng.unitOfMeasure = uom;
        }
        oIng.description = remainingDesc.trim();
      }
    }
    if (!(options == null ? void 0 : options.allowLeadingOf) && oIng.description.match(ofRegEx)) {
      oIng.description = oIng.description.replace(ofRegEx, "");
    }
    return oIng;
  });
  return arrIngs;
};
export {
  firstWordRegEx,
  fors,
  forsRegEx,
  ofRegEx,
  ofs,
  parseIngredient,
  rangeSeparatorRegEx,
  rangeSeparatorWords,
  unitsOfMeasure
};
//# sourceMappingURL=parse-ingredient.es.js.map
