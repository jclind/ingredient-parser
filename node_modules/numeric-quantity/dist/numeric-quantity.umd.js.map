{"version":3,"file":"numeric-quantity.umd.js","sources":["../src/index.ts"],"sourcesContent":["enum VulgarFraction {\n  '¼' = '1/4',\n  '½' = '1/2',\n  '¾' = '3/4',\n  '⅐' = '1/7',\n  '⅑' = '1/9',\n  '⅒' = '1/10',\n  '⅓' = '1/3',\n  '⅔' = '2/3',\n  '⅕' = '1/5',\n  '⅖' = '2/5',\n  '⅗' = '3/5',\n  '⅘' = '4/5',\n  '⅙' = '1/6',\n  '⅚' = '5/6',\n  '⅛' = '1/8',\n  '⅜' = '3/8',\n  '⅝' = '5/8',\n  '⅞' = '7/8',\n}\n\n/**\n * Converts a string to a number.  The string can include mixed numbers\n * or vulgar fractions.\n */\nfunction numericQuantity(qty: string) {\n  const badResult = NaN;\n  let finalResult = badResult;\n\n  // Resolve any unicode vulgar fractions\n  const vulgarFractionsRegex = /(¼|½|¾|⅐|⅑|⅒|⅓|⅔|⅕|⅖|⅗|⅘|⅙|⅚|⅛|⅜|⅝|⅞)/;\n\n  const sQty = `${qty}`\n    .replace(\n      vulgarFractionsRegex,\n      (_m, vf: keyof typeof VulgarFraction) => ` ${VulgarFraction[vf]}`\n    )\n    .replace(/⁄/g, '/')\n    .trim();\n\n  /**\n   *                    Regex captures\n   *\n   *  +=====+====================+========================+\n   *  |  #  |    Description     |        Example         |\n   *  +=====+====================+========================+\n   *  |  0  |  entire string     |  \"2 2/3\" from \"2 2/3\"  |\n   *  +-----+--------------------+------------------------+\n   *  |  1  |  the dash          |  \"-\" from \"-2 2/3\"     |\n   *  +-----+--------------------+------------------------+\n   *  |  2  |  the whole number  |  \"2\" from \"2 2/3\"      |\n   *  |     |  - OR -            |                        |\n   *  |     |  the numerator     |  \"2\" from \"2/3\"        |\n   *  +-----+--------------------+------------------------+\n   *  |  3  |  entire fraction   |  \"2/3\" from \"2 2/3\"    |\n   *  |     |  - OR -            |                        |\n   *  |     |  decimal portion   |  \".66\" from \"2.66\"     |\n   *  |     |  - OR -            |                        |\n   *  |     |  denominator       |  \"/3\" from \"2/3\"       |\n   *  +=====+====================+========================+\n   *\n   *  re.exec(\"1\")       // [ \"1\",     \"1\", null,   null ]\n   *  re.exec(\"1.23\")    // [ \"1.23\",  \"1\", \".23\",  null ]\n   *  re.exec(\"1 2/3\")   // [ \"1 2/3\", \"1\", \" 2/3\", \" 2\" ]\n   *  re.exec(\"2/3\")     // [ \"2/3\",   \"2\", \"/3\",   null ]\n   *  re.exec(\"2 / 3\")   // [ \"2 / 3\", \"2\", \"/ 3\",  null ]\n   */\n  const re = /^(-)?\\s*(\\d*)(\\.\\d+|(\\s+\\d*\\s*)?\\s*\\/\\s*\\d+)?$/;\n\n  const ar = re.exec(sQty);\n\n  // If the regex fails, give up\n  if (!ar) {\n    return badResult;\n  }\n\n  // Store the capture groups so we don't have to access the array\n  // elements over and over\n  const [, dash, numberGroup1, numberGroup2] = ar;\n\n  // The regex can pass and still capture nothing in the relevant groups,\n  // which means it failed for our purposes\n  if (!numberGroup1 && !numberGroup2) {\n    return badResult;\n  }\n\n  // Numerify capture group 1\n  if (!numberGroup1 && numberGroup2 && numberGroup2.search(/^\\./) !== -1) {\n    finalResult = 0;\n  } else {\n    finalResult = parseInt(numberGroup1);\n  }\n\n  if (isNaN(finalResult)) {\n    return badResult;\n  }\n\n  // If capture group 2 is null, then we're dealing with an integer\n  // and there is nothing left to process\n  if (!numberGroup2) {\n    return finalResult * (dash === '-' ? -1 : 1);\n  }\n\n  if (numberGroup2.search(/^\\./) !== -1) {\n    // If first char is \".\" it's a decimal so just trim to 3 decimal places\n    const numerator = parseFloat(numberGroup2);\n    finalResult += Math.round(numerator * 1000) / 1000;\n  } else if (numberGroup2.search(/^\\s*\\//) !== -1) {\n    // If the first non-space char is \"/\" it's a pure fraction (e.g. \"1/2\")\n    const numerator = parseInt(numberGroup1);\n    const denominator = parseInt(numberGroup2.replace('/', ''));\n    finalResult = Math.round((numerator * 1000) / denominator) / 1000;\n  } else {\n    // Otherwise it's a mixed fraction (e.g. \"1 2/3\")\n    const fractionArray = numberGroup2.split('/');\n    const [numerator, denominator] = fractionArray.map(v => parseInt(v));\n    finalResult += Math.round((numerator * 1000) / denominator) / 1000;\n  }\n\n  return finalResult * (dash === '-' ? -1 : 1);\n}\n\nexport default numericQuantity;\n"],"names":[],"mappings":"kPAAA,GAAK,IAAA,GACG,GAAA,QAAA,MACA,EAAA,QAAA,MACA,EAAA,QAAA,MACA,EAAA,UAAA,MACA,EAAA,UAAA,MACA,EAAA,UAAA,OACA,EAAA,UAAA,MACA,EAAA,UAAA,MACA,EAAA,UAAA,MACA,EAAA,UAAA,MACA,EAAA,UAAA,MACA,EAAA,UAAA,MACA,EAAA,UAAA,MACA,EAAA,UAAA,MACA,EAAA,UAAA,MACA,EAAA,UAAA,MACA,EAAA,UAAA,MACA,EAAA,UAAA,MAlBH,IAAA,GAAA,CAAA,CAAA,EAyBL,WAAyB,EAAa,CAEpC,GAAI,GAAc,IAGlB,KAAM,GAAuB,wCAEvB,EAAO,GAAG,IACb,QACC,EACA,CAAC,EAAI,IAAoC,IAAI,EAAe,IAC9D,EACC,QAAQ,KAAM,GAAG,EACjB,OA+BG,EAAK,AAFA,iDAEG,KAAK,CAAI,EAGvB,GAAI,CAAC,EACI,MAAA,KAKT,KAAM,CAAG,CAAA,EAAM,EAAc,GAAgB,EAIzC,GAAA,CAAC,GAAgB,CAAC,EACb,MAAA,KAUL,GANJ,AAAI,CAAC,GAAgB,GAAgB,EAAa,OAAO,KAAK,IAAM,GACpD,EAAA,EAEd,EAAc,SAAS,CAAY,EAGjC,MAAM,CAAW,EACZ,MAAA,KAKT,GAAI,CAAC,EACI,MAAA,GAAwB,KAAA,IAAM,GAAK,GAG5C,GAAI,EAAa,OAAO,KAAK,IAAM,GAAI,CAE/B,KAAA,GAAY,WAAW,CAAY,EACzC,GAAe,KAAK,MAAM,EAAY,GAAI,EAAI,GACrC,SAAA,EAAa,OAAO,QAAQ,IAAM,GAAI,CAEzC,KAAA,GAAY,SAAS,CAAY,EACjC,EAAc,SAAS,EAAa,QAAQ,IAAK,EAAE,CAAC,EAC1D,EAAc,KAAK,MAAO,EAAY,IAAQ,CAAW,EAAI,GAAA,KACxD,CAEC,KAAA,GAAgB,EAAa,MAAM,GAAG,EACtC,CAAC,EAAW,GAAe,EAAc,IAAI,AAAK,GAAA,SAAS,CAAC,CAAC,EACnE,GAAe,KAAK,MAAO,EAAY,IAAQ,CAAW,EAAI,GAChE,CAEO,MAAA,GAAwB,KAAA,IAAM,GAAK,EAC5C"}