{"version":3,"file":"numeric-quantity.es.js","sources":["../src/index.ts"],"sourcesContent":["enum VulgarFraction {\n  '¼' = '1/4',\n  '½' = '1/2',\n  '¾' = '3/4',\n  '⅐' = '1/7',\n  '⅑' = '1/9',\n  '⅒' = '1/10',\n  '⅓' = '1/3',\n  '⅔' = '2/3',\n  '⅕' = '1/5',\n  '⅖' = '2/5',\n  '⅗' = '3/5',\n  '⅘' = '4/5',\n  '⅙' = '1/6',\n  '⅚' = '5/6',\n  '⅛' = '1/8',\n  '⅜' = '3/8',\n  '⅝' = '5/8',\n  '⅞' = '7/8',\n}\n\n/**\n * Converts a string to a number.  The string can include mixed numbers\n * or vulgar fractions.\n */\nfunction numericQuantity(qty: string) {\n  const badResult = NaN;\n  let finalResult = badResult;\n\n  // Resolve any unicode vulgar fractions\n  const vulgarFractionsRegex = /(¼|½|¾|⅐|⅑|⅒|⅓|⅔|⅕|⅖|⅗|⅘|⅙|⅚|⅛|⅜|⅝|⅞)/;\n\n  const sQty = `${qty}`\n    .replace(\n      vulgarFractionsRegex,\n      (_m, vf: keyof typeof VulgarFraction) => ` ${VulgarFraction[vf]}`\n    )\n    .replace(/⁄/g, '/')\n    .trim();\n\n  /**\n   *                    Regex captures\n   *\n   *  +=====+====================+========================+\n   *  |  #  |    Description     |        Example         |\n   *  +=====+====================+========================+\n   *  |  0  |  entire string     |  \"2 2/3\" from \"2 2/3\"  |\n   *  +-----+--------------------+------------------------+\n   *  |  1  |  the dash          |  \"-\" from \"-2 2/3\"     |\n   *  +-----+--------------------+------------------------+\n   *  |  2  |  the whole number  |  \"2\" from \"2 2/3\"      |\n   *  |     |  - OR -            |                        |\n   *  |     |  the numerator     |  \"2\" from \"2/3\"        |\n   *  +-----+--------------------+------------------------+\n   *  |  3  |  entire fraction   |  \"2/3\" from \"2 2/3\"    |\n   *  |     |  - OR -            |                        |\n   *  |     |  decimal portion   |  \".66\" from \"2.66\"     |\n   *  |     |  - OR -            |                        |\n   *  |     |  denominator       |  \"/3\" from \"2/3\"       |\n   *  +=====+====================+========================+\n   *\n   *  re.exec(\"1\")       // [ \"1\",     \"1\", null,   null ]\n   *  re.exec(\"1.23\")    // [ \"1.23\",  \"1\", \".23\",  null ]\n   *  re.exec(\"1 2/3\")   // [ \"1 2/3\", \"1\", \" 2/3\", \" 2\" ]\n   *  re.exec(\"2/3\")     // [ \"2/3\",   \"2\", \"/3\",   null ]\n   *  re.exec(\"2 / 3\")   // [ \"2 / 3\", \"2\", \"/ 3\",  null ]\n   */\n  const re = /^(-)?\\s*(\\d*)(\\.\\d+|(\\s+\\d*\\s*)?\\s*\\/\\s*\\d+)?$/;\n\n  const ar = re.exec(sQty);\n\n  // If the regex fails, give up\n  if (!ar) {\n    return badResult;\n  }\n\n  // Store the capture groups so we don't have to access the array\n  // elements over and over\n  const [, dash, numberGroup1, numberGroup2] = ar;\n\n  // The regex can pass and still capture nothing in the relevant groups,\n  // which means it failed for our purposes\n  if (!numberGroup1 && !numberGroup2) {\n    return badResult;\n  }\n\n  // Numerify capture group 1\n  if (!numberGroup1 && numberGroup2 && numberGroup2.search(/^\\./) !== -1) {\n    finalResult = 0;\n  } else {\n    finalResult = parseInt(numberGroup1);\n  }\n\n  if (isNaN(finalResult)) {\n    return badResult;\n  }\n\n  // If capture group 2 is null, then we're dealing with an integer\n  // and there is nothing left to process\n  if (!numberGroup2) {\n    return finalResult * (dash === '-' ? -1 : 1);\n  }\n\n  if (numberGroup2.search(/^\\./) !== -1) {\n    // If first char is \".\" it's a decimal so just trim to 3 decimal places\n    const numerator = parseFloat(numberGroup2);\n    finalResult += Math.round(numerator * 1000) / 1000;\n  } else if (numberGroup2.search(/^\\s*\\//) !== -1) {\n    // If the first non-space char is \"/\" it's a pure fraction (e.g. \"1/2\")\n    const numerator = parseInt(numberGroup1);\n    const denominator = parseInt(numberGroup2.replace('/', ''));\n    finalResult = Math.round((numerator * 1000) / denominator) / 1000;\n  } else {\n    // Otherwise it's a mixed fraction (e.g. \"1 2/3\")\n    const fractionArray = numberGroup2.split('/');\n    const [numerator, denominator] = fractionArray.map(v => parseInt(v));\n    finalResult += Math.round((numerator * 1000) / denominator) / 1000;\n  }\n\n  return finalResult * (dash === '-' ? -1 : 1);\n}\n\nexport default numericQuantity;\n"],"names":[],"mappings":"AAAA,IAAK,mCAAA,oBAAL;AACQ,kBAAA,UAAA;AACA,kBAAA,UAAA;AACA,kBAAA,UAAA;AACA,kBAAA,YAAA;AACA,kBAAA,YAAA;AACA,kBAAA,YAAA;AACA,kBAAA,YAAA;AACA,kBAAA,YAAA;AACA,kBAAA,YAAA;AACA,kBAAA,YAAA;AACA,kBAAA,YAAA;AACA,kBAAA,YAAA;AACA,kBAAA,YAAA;AACA,kBAAA,YAAA;AACA,kBAAA,YAAA;AACA,kBAAA,YAAA;AACA,kBAAA,YAAA;AACA,kBAAA,YAAA;AAlBH,SAAA;AAAA,GAAA,kBAAA,CAAA,CAAA;AAyBL,yBAAyB,KAAa;AACpC,QAAM,YAAY;AAClB,MAAI,cAAc;AAGlB,QAAM,uBAAuB;AAE7B,QAAM,OAAO,GAAG,MACb,QACC,sBACA,CAAC,IAAI,OAAoC,IAAI,eAAe,KAC9D,EACC,QAAQ,MAAM,GAAG,EACjB;AA6BH,QAAM,KAAK;AAEL,QAAA,KAAK,GAAG,KAAK,IAAI;AAGvB,MAAI,CAAC,IAAI;AACA,WAAA;AAAA,EACT;AAIA,QAAM,CAAG,EAAA,MAAM,cAAc,gBAAgB;AAIzC,MAAA,CAAC,gBAAgB,CAAC,cAAc;AAC3B,WAAA;AAAA,EACT;AAGA,MAAI,CAAC,gBAAgB,gBAAgB,aAAa,OAAO,KAAK,MAAM,IAAI;AACxD,kBAAA;AAAA,EAAA,OACT;AACL,kBAAc,SAAS,YAAY;AAAA,EACrC;AAEI,MAAA,MAAM,WAAW,GAAG;AACf,WAAA;AAAA,EACT;AAIA,MAAI,CAAC,cAAc;AACV,WAAA,cAAwB,UAAA,MAAM,KAAK;AAAA,EAC5C;AAEA,MAAI,aAAa,OAAO,KAAK,MAAM,IAAI;AAE/B,UAAA,YAAY,WAAW,YAAY;AACzC,mBAAe,KAAK,MAAM,YAAY,GAAI,IAAI;AAAA,EACrC,WAAA,aAAa,OAAO,QAAQ,MAAM,IAAI;AAEzC,UAAA,YAAY,SAAS,YAAY;AACvC,UAAM,cAAc,SAAS,aAAa,QAAQ,KAAK,EAAE,CAAC;AAC1D,kBAAc,KAAK,MAAO,YAAY,MAAQ,WAAW,IAAI;AAAA,EAAA,OACxD;AAEC,UAAA,gBAAgB,aAAa,MAAM,GAAG;AACtC,UAAA,CAAC,WAAW,eAAe,cAAc,IAAI,CAAK,MAAA,SAAS,CAAC,CAAC;AACnE,mBAAe,KAAK,MAAO,YAAY,MAAQ,WAAW,IAAI;AAAA,EAChE;AAEO,SAAA,cAAwB,UAAA,MAAM,KAAK;AAC5C;;"}